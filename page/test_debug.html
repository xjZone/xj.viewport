<!doctype html>
<html lang="zh-cmn-hans">
<head>
<meta charset="utf-8" />
<meta name="renderer" content="webkit" />
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<!-- <meta name="viewport" xj-viewport="{minWidth:400, }" content="width=device-width,initial-scale=1" /> -->
<!-- <script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script> -->

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.2/css/all.min.css" />
<script src="https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
<script src="../static/cj/xj.plugins.setting.js"></script>

<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.storage@0.2.2/dist/xj.storage.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.operate@0.5.0/dist/xj.operate.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xjZone/xj.ripple@0.3.2/dist/xj.ripple.min.css" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.ripple@0.3.2/dist/xj.ripple.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xjZone/xj.focus@0.3.2/dist/xj.focus.min.css" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.focus@0.3.2/dist/xj.focus.min.js"></script>

<link id="prism-theme-white" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.7.0/themes/prism-material-light.css" />
<link id="prism-theme-black" rel="alternate stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism-okaidia.css" />
<script data-manual="prevent prism auto highlighted pre or code" src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/prism.js"></script>

<link rel="stylesheet" href="../static/plugin/xjDemo/0.1.0/dist/xjDemo.min.css" />
<script src="../static/plugin/xjDemo/0.1.0/dist/xjDemo.min.js"></script>

<!-- <script>document.addEventListener('DOMContentLoaded',function(){FastClick.attach(document.body)},false);</script> -->
<!-- <style>html[class~="xj-base-black"] body{background-color:#333;color:#fff;}</style> -->

<!--◇
<link rel="stylesheet" href="../static/plugin/xj.base/0.4.0/dist/xj.base.css" />
<script src="../static/plugin/xj.base/0.4.0/dist/xj.base.js"></script>
◇-->

<!--◇
<link rel="stylesheet" href="../dist/xj.viewport.css" />
<script src="../dist/xj.viewport.js"></script>
◇-->

<style>
@font-face{font-family:"Iosevka";src:local('Iosevka'), url("../static/font/iosevka/6.1.2/iosevka-fixed-regular.woff2") format("woff2"), url("../static/font/iosevka/6.1.2/iosevka-fixed-regular.woff") format("woff");}
a{background-color:transparent;text-decoration:none;cursor:pointer;color:#39f;} html:not(.xj-operate-touch) a:hover{text-decoration:underline;color:#4af;}
body{box-sizing:border-box;margin:0;padding:0 32px;max-width:1024px;font:16px/1.5 Iosevka,'Microsoft YaHei','Hiragino Sans GB';}
code{padding:0 8px;background-color:#f0f0f0;color:#f39;font-family:inherit;}
a > code{color:inherit;}
</style>
<title>xj.viewport_debug</title>
</head>
<body>



<section>
<h2>窗口设置的须知</h2>

<p>设置窗口尺寸，有两点需要注意，首先是这个设置只对移动端有效，但 Demo 可在 PC 端用 Chrome 的移动模拟查看，其次是插件提供了 <code>minWidth & minHeight</code> 和 <code>width & height</code> 和 <code>maxWidth & maxHeight</code> 共三对属性来设置尺寸，但和 <code>div</code> 等标签不同的是，视窗尺寸是有固定比例的，改动宽度会引发高度变化，反之亦然，所以这三对属性只能是单独使用，因为同时使用可能会引发宽高度冲突。</p>

<hr />
</section>



<section>
<h2>插件的提前加载</h2>

<p>最好在 <code>&lt;head&gt;</code> 中的 <code>meta[name="viewport"]</code> 标签后就加载该插件并执行它的 <code>set()</code> 方法，如果将插件放到 <code>&lt;body&gt;</code> 渲染后才加载执行，页面就可能抖动或闪屏，这是因为插件可能会重设视窗尺寸，导致回流和重绘，如果你担心 JS 前置会让页面加载受阻，那么可用响应头信息中有设置 <code>immutable</code> 属性的 CDN 如 <a target="_blank" href="https://www.jsdelivr.com/">jsdelivr</a> 的 CDN，关于该属性可参考 <a target="_blank" href="https://www.cnblogs.com/ziyunfei/p/5642796.html">扼杀 304，Cache-Control : immutable</a>。</p>

<p><code>Cache-Control</code> 有 <code>immutable</code> 属性，则文件在本地有缓存，就不会再向服务器发送结果为 304 的请求了，浏览器将直接使用本地的缓存文件，这样相对的就会快上许多，当然你也可以选择为 <code>&lt;body&gt;</code> 设置 <code>display:none</code>，在执行完 <code>set()</code> 方法后才将 <code>&lt;body&gt;</code> 显示出来，之后我们提到的案例，为了简单都选择在 <code>&lt;head&gt;</code> 中加载并执行，在实际项目中，可选择更适合你项目的加载和执行方案。</p>

<hr />
</section>



<section>
<h2>两种执行的模式</h2>
<p>插件有两种执行模式，一是在 <code>meta[name="viewport"]</code> 标签设置 <code>xj-viewport="{}"</code> 属性，让插件自动执行 <code>xj.viewport.set()</code> 方法，这种模式较为简洁，推荐使用这种，二是不写 <code>xj-viewport</code> 属性，改为手动执行 <code>xj.viewport.set()</code> 方法，下面的两段代码分别展示了这两种模式，你可以自由选择，但代码结果都是一样的 : 当页面的视窗宽度小于 <code>400px</code> 时，将视窗宽度设置为 <code>400px</code>。</p>

<textarea class="xjDemo" xjDemo="{onlySource:true}">
<!-- 模式01：推荐，为 meta 标签设置 xj-viewport 属性，在文件加载后，会解析这个属性对象并自动执行 -->
<meta name="viewport" xj-viewport="{minWidth:400, }" content="width=device-width,initial-scale=1" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>
</textarea>

<textarea class="xjDemo" xjDemo="{onlySource:true}">
<!-- 模式02：手动执行 set() 方法 -->
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>
<script>xj.viewport.set({minWidth:400});</script>
</textarea>

<hr />
</section>



<section>
<h2>Demo01. 设置一个最小宽度</h2>
<p>例如 iPhone4/5 的设备宽度既 <code>device-width</code> 为 <code>320px</code>，你觉得这个值太小了，想要个大点的值，可用下面这写法来实现，内联属性 <code>xj-viewport="{minWidth:512}"</code> 的意思是当设备宽度小于 <code>512px</code> 就将设备宽度设置为 <code>512px</code>，当设备宽度大于等于 <code>512px</code> 则不做任何修改，注意视窗属性只对移动端浏览器生效，但可用 Chrome 的移动端模拟来查看，之后的例子也都是这样，不再重复提示。</p>
<p>点击链接即可查看 Demo 效果，实际上 Demo 页面还多了些提示的内容，诸如 <code>meta[name="viewport"]</code> 标签的 <code>content</code> 属性，以及当前视窗的宽高度和方向，下面展示出来的代码只写了些关键部分，虽然也能运行，但没有真实 Demo 页面那么多的信息，有兴趣可自行查看 Demo 页面的源码，后面的例子也都是这样，只展示关键性的内容，所以如果你发现代码和 Demo 内容有些许区别，那都是正常的。</p>

<textarea class="xjDemo" xjDemo="{larger:true, sourceShow:true, resultContent:'查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./demo_01_minWidth.html&quot;&gt;minWidth.html&lt;/a&gt;',}">
<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" xj-viewport="{minWidth:512, }" content="width=device-width,initial-scale=1" />
		<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>
		<style>
			html,body{margin:0px;-webkit-text-size-adjust:100%;}
			.div01{width:256px;background-color:yellowgreen;}
			.div02{width:384px;background-color:lightblue;}
			.div03{width:512px;background-color:bisque;}
		</style>
		<title>minWidth</title>
	</head>
	<body>
		<div class="div01">width : 256px</div>
		<div class="div02">width : 384px</div>
		<div class="div03">width : 512px</div>
	</body>
</html>
</textarea>

<hr />
</section>



<section>
<h2>Demo02. 设置一个最小高度</h2>
<p>例如 iPhone4/iPhone5 的设备高度既 <code>device-height</code> 为 <code>480px/568px</code>，你觉得这个值太小了，想要个大点的值，可用下面这写法来实现，内联属性 <code>xj-viewport="{minHeight:768}"</code> 的意思是当页面高度小于 <code>768px</code> 就将高度设置为 <code>768px</code>，当设备高度大于等于 <code>768px</code> 则不做任何的修改，跟上面的那个例子一样，下面的代码是 Demo 的简化版本，少了一些提示信息，有兴趣的可自行查看源码。</p>
<p>其实 <code>viewport</code> 的 <code>height</code> 属性并没有得到任何浏览器的支持，插件实际上是用 <code>width</code> 属性和 <code>initial-scale</code> 属性的计算来实现最小高度，但大部分移动端的浏览器在滚动后，地址栏都会收起或展开，导致窗口的高度会频繁变化，但我们却不能跟着频繁修改视窗属性，因为这样会引起页面抖动和视窗比例出错，总而言之，我们设置的最小高度，都只在页面滚动前是准确的，滚动之后就不一定了。</p>
<p>还要注意的是，视窗的最小高度是由 <code>width</code> 和 <code>initial-scale</code> 属性计算出来，但 <code>viewport</code> 的 <code>width</code> 属性并不支持小数，所以我们只能将 <code>width</code> 属性进行四舍五入取整，结果就导致最终计算出来的高度可能会有些偏差，无法保证绝对准确，如果你发现下面这个例子，窗口的高度是 <code>767px</code> 或 <code>769px</code>，那也是正常的，对于偏差问题，只能是开发者写 CSS 的时候注意一下，自行去兼容了。</p>

<textarea class="xjDemo" xjDemo="{larger:true, sourceShow:true, resultContent:'查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./demo_02_minHeight.html&quot;&gt;minHeight.html&lt;/a&gt;',}">
<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" xj-viewport="{minHeight:768,}" content="width=device-width,initial-scale=1" />
		<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>
		<style>
			html,body{margin:0px;-webkit-text-size-adjust:100%;}
			.div01{height:384px;background-color:yellowgreen;}
			.div02{height:384px;background-color:lightsalmon;}
			.div03{height:384px;background-color:lightblue;}
			.div04{height:384px;background-color:bisque;}
		</style>
		<title>minHeight</title>
	</head>
	<body>
		<div class="div01">height : 384px</div>
		<div class="div02">height : 384px</div>
		<div class="div03">height : 384px</div>
		<div class="div04">height : 384px</div>
	</body>
</html>
</textarea>

<hr />
</section>



<section>
<h2>Demo03. 设置最小的宽高度</h2>
<p>最小宽度和最小高度也可以同时设置，例如下面这个 Demo，内联属性 <code>xj-viewport="{minWidth:512, minHeight:768}"</code> 的意思是将视窗的最小宽度和最小高度高分别设为 <code>512px</code> 和 <code>768px</code>，当页面的尺寸小于这个设置时将进行特殊的调整，确保屏幕总是能放下这个尺寸的内容，当设备宽高度分别大于 <code>512px</code> 和 <code>768px</code> 时，则不做任何修改，可以简单的将这例子当作是前面两个例子的综合表现。</p>
<p>移动端一般用不着设置这么大的最小尺寸，这 Demo 只是为了方便查看效果而故意整出来的，跟第二个实例一样的原因，它的最小高度只在滚动前是准确的，滚动后就无法保证了，并且也可能会出现高度有 <code>± 2px</code> 偏差的问题，还有就是 Firefox(Android) 浏览器可能会出现明明不能滚动，但地址栏却还是会上下伸缩的情况，所以特别的为这个浏览器设置禁止滚动，避免在这个浏览器中尺寸会出现异常。</p>

<textarea class="xjDemo" xjDemo="{larger:true, sourceShow:true, resultContent:'查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./demo_03_minSize.html&quot;&gt;minSize.html&lt;/a&gt;',}">
<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" xj-viewport="{minWidth:512, minHeight:768}" content="width=device-width,initial-scale=1" />
		<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>
		<style>
			html,body{margin:0;overflow:hidden;-webkit-text-size-adjust:100%;background-color:yellowgreen;}
			.pack{position:absolute;top:50%;left:50%;margin:-384px 0 0 -256px;width:512px;height:768px;background-color:lightblue;}
		</style>
		<title>minSize</title>
	</head>
	<body>
		<div class="pack">这个 div 的尺寸是 512px * 768px，如果设备尺寸小于插件设置的值，则视窗会被设置为符合这个值，如果大于则不做修改。</div>
		<script>
			// 阻止 Firefox(Android) 触屏滚动，这样可以解决浏览器尺寸计算 BUG
			if(/Firefox/i.test(navigator.userAgent) && /Android/i.test(navigator.userAgent)){
				document.addEventListener('touchmove', function(event){
					if(event.touches.length >= 2){ return };
					event.preventDefault();
				}, {passive:false});
			};
		</script>
	</body>
</html>
</textarea>

<hr />
</section>



<section>
<h2>Demo04. 限制尺寸填充屏幕</h2>
<p>下面这个例子的设置是 <code>xj-viewport="{minWidth:320, minHeight:480, fillScreen:true}"</code>，跟上面的实例类似，但这回最小宽高度被设置为 <code>320px * 480px</code>，并额外增加了 <code>fillScreen:true</code> 属性，意思是如果设备的宽高度大于我们设置的最小宽高度，就让设备宽高度变成我们设置的这个值，说白了就是将视窗缩小，或者说将内容放大，具体的表现，你点击 Demo 链接，自己体验一下就知道了。</p>
<p>一般的页面，设置 <code>minWidth</code> 就够了，需要用到 <code>minHeight</code>，往往是那种 fullPage 整屏翻页项目，这类项目不能滚动，拖曳时是整页切换的，此时设置最小宽高度的功能就能用上了，这有个更复杂的案例 : <a target="_blank" href="./demo_11_fullPage.html">fullPage</a>，它增加了更多细节，页面用到了 <a target="_blank" href="https://github.com/jquery/jquery">jQuery</a> 库以及 <a target="_blank" href="https://github.com/rstacruz/jquery.transit">jQuery-transit</a> 插件，该插件能让 jQuery 支持 <code>transform</code> 动画，它将 <code>translateY</code> 属性简化为 <code>y</code>，更多细节可自行查看源码。</p>
<p>在上面的这个 fullPage 案例中，XJ 自己实现了拖曳翻页的功能，但实际上这类需求，业界已有很多现成且成熟的方案，如 <a target="_blank" href="https://www.swiper.com.cn/">swiper</a> 或 <a target="_blank" href="https://alvarotrigo.com/fullPage/">fullPage</a> 插件(该插件是收费的)都可以做到，但这些跟 xj.viewport 插件都没什么关系，在这里就不多说了，有兴趣的可以自行研究，然而不管你选择了什么方案来实现拖曳翻页的功能，你总是需要设置到页面的最小视窗尺寸，此时 xj.viewport 插件就能派上用场了。</p>

<textarea class="xjDemo" xjDemo="{larger:true, sourceShow:true, resultContent:'查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./demo_04_minFill.html&quot;&gt;minFill.html&lt;/a&gt;',}">
<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" xj-viewport="{minWidth:320, minHeight:480, fillScreen:true}" content="width=device-width,initial-scale=1" />
		<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>
		<style>
			html,body{margin:0;overflow:hidden;-webkit-text-size-adjust:100%;background-color:yellowgreen;}
			.pack{position:absolute;top:50%;left:50%;margin:-240px 0 0 -160px;width:320px;height:480px;background-color:lightblue;}
		</style>
		<title>minFill</title>
	</head>
	<body>
		<div class="pack">这个 div 的尺寸是 320px * 480px，由于设置 fillScreen:true，所以内容会填充屏幕，也就是当设备尺寸大于插件设置的最小尺寸 320px * 480px 则视窗会缩小。</div>
		<script>
			// 阻止 Firefox(Android) 触屏滚动，这样可以解决浏览器尺寸计算 BUG
			if(/Firefox/i.test(navigator.userAgent) && /Android/i.test(navigator.userAgent)){
				document.addEventListener('touchmove', function(event){
					if(event.touches.length >= 2){ return };
					event.preventDefault();
				}, {passive:false});
			};
		</script>
	</body>
</html>
</textarea>

<hr />
</section>



<section>
<h2>Demo05. 设置固定的宽度值</h2>
<p>下面这个例子的设置是 <code>xj-viewport="{width:512}"</code>，意思是不管设备的原始宽度尺寸是多少，反正就将宽度尺寸固定为 <code>512px</code>，但实际上这种做法很少会被用到，因为这样会导致在一些大屏设备如 iPad 中显得很怪异，因为页面的尺寸会被放大许多，导致页面显得臃肿不堪，如果设置的尺寸太大了，在小屏设备上又会因为内容过小而难以看清，总而言之固定尺寸的做法意义不大，这里只是简单展示。</p>

<textarea class="xjDemo" xjDemo="{larger:true, sourceShow:true, resultContent:'查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./demo_05_width.html&quot;&gt;width.html&lt;/a&gt;',}">
<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" xj-viewport="{width:512}" content="width=device-width,initial-scale=1" />
		<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>
		<style>
			html,body{margin:0px;-webkit-text-size-adjust:100%;}
			.div01{width:256px;background-color:yellowgreen;}
			.div02{width:384px;background-color:lightblue;}
			.div03{width:512px;background-color:bisque;}
		</style>
		<title>width</title>
	</head>
	<body>
		<div class="div01">width : 256px</div>
		<div class="div02">width : 384px</div>
		<div class="div03">width : 512px</div>
	</body>
</html>
</textarea>

<hr />
</section>



<section>
<h2>Demo06. 设置固定的高度值</h2>
<p>下面这个例子的设置是 <code>xj-viewport="{height:768}"</code>，意思为不管设备的原始高度值是多少，反正就将高度尺寸固定为 <code>768px</code> 了，固定高度跟上面的固定宽度的例子相同的在展示上有缺陷，在有些设备上看着总会很怪异，所以也很少会被用到，此外固定高度也跟上面的设置最小高度的例子一样，存在因不支持小数而导致高度可能会有 <code>± 2px</code> 的偏差，总而言之固定高度的做法在实际上意义也不大。</p>
<p>需要注意的是，跟 <code>minWidth</code> 和 <code>minHeight</code> 这对属性不同，设置固定尺寸的 <code>width</code> 和 <code>height</code> 这对属性不能同时存在且生效，因为屏幕的尺寸和 <code>div</code> 等标签不同，它是有固定比例的，宽度变化会影响到高度，高度变化也会影响到宽度，并且由于这个原因，设置固定尺寸的这对属性，跟 <code>minWidth & minHeight</code> 这对属性以及后面将提到的 <code>maxWidth & maxHeight</code> 这对属性也不能同时存在。</p>

<textarea class="xjDemo" xjDemo="{larger:true, sourceShow:true, resultContent:'查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./demo_06_height.html&quot;&gt;height.html&lt;/a&gt;',}">
<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" xj-viewport="{height:768}" content="width=device-width,initial-scale=1" />
		<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>
		<style>
			html,body{margin:0px;-webkit-text-size-adjust:100%;}
			.div01{height:384px;background-color:yellowgreen;}
			.div02{height:384px;background-color:lightsalmon;}
			.div03{height:384px;background-color:lightblue;}
			.div04{height:384px;background-color:bisque;}
		</style>
		<title>height</title>
	</head>
	<body>
		<div class="div01">height : 512px</div>
		<div class="div02">height : 512px</div>
		<div class="div03">height : 512px</div>
		<div class="div04">height : 512px</div>
	</body>
</html>
</textarea>

<hr />
</section>



<section>
<h2>Demo07. 设置最大的宽高度</h2>
<p>插件还提供了 <code>maxWidth & maxHeight</code> 这对属性，用于设置窗口的最大尺寸，但用法跟 <code>minWidth & minHeight</code> 这对属性也没什么区别，所以这里也不再啰嗦的逐个案例展示代码，有兴趣可直接查看这些 Demo 既 <a target="_blank" href="./demo_07_maxWidth.html">maxWidth</a> 和 <a target="_blank" href="./demo_08_maxHeight.html">maxHeight</a> 和 <a target="_blank" href="./demo_09_maxSize.html">maxSize</a>，XJ 虽然提供了这些属性和 Demo，但实际上它们究竟有什么使用场景，XJ 其实也没想出来，只是顺手提供了而已，毕竟限制窗口的最大尺寸真的很少见…</p>
<p>值得一提的是设置最大尺寸的两个属性也能配合 <code>fillScreen</code> 属性使用，但此时的结果就变成如果设备尺寸小于设置的最大尺寸，将会放大设备的尺寸，到达设置的最大尺寸值，说白了就是限制最大尺寸，但同时又在尺寸未到达最大尺寸时候设置为最大尺寸，听着很绕？自己点击 Demo 体会吧，实在看不懂也无所谓，这个案例就随他去吧，反正 XJ 也没想到有什么有能用到的场景，纯粹就只是凑数而已。</p>
<p>最后解释一下，为什么设置尺寸的三对属性不能同时存在，例如设备的尺寸是 <code>400 * 600</code>，<code>minWidth & minHeight</code> 被设置为 <code>600 * 600</code>，那么设备尺寸将变成 <code>600 * 900</code>，<code>maxWidth & maxHeight</code> 设置为 <code>600 * 600</code>，那么设备的尺寸将变成 <code>400 * 600</code>，此时两对属性的设置就有冲突，而固定尺寸的 <code>width & height</code> 还会让情况变得更乱，总之固定比例的屏幕尺寸就是没法随心所欲设置啦。</p>

<textarea class="xjDemo" xjDemo="{larger:true, sourceShow:true, resultContent:'查看 Demo 页面 : &lt;a target=&quot;_blank&quot; href=&quot;./demo_10_maxFill.html&quot;&gt;maxFill.html&lt;/a&gt;',}">
<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" xj-viewport="{maxWidth:768, maxHeight:768, fillScreen:true}" content="width=device-width,initial-scale=1" />
		<script src="https://cdn.jsdelivr.net/gh/xjZone/xj.viewport@0.3.2/dist/xj.viewport.min.js"></script>
		<style>
			html{overflow:hidden;display:table;width:100%;height:100%;text-align:center;-webkit-text-size-adjust:100%;}
			body{overflow:hidden;display:table-cell;margin:0;background-color:yellowgreen;vertical-align:middle;}
			.pack{display:inline-block;width:256px;height:256px;background-color:lightblue;text-align:left;}
		</style>
		<title>maxFill</title>
	</head>
	<body>
		<div class="pack">跟 maxSize 的 Demo 相比就是多了 fillScreen:true 的设置，如果设备尺寸小于设置的最大尺寸，将会放大设备的尺寸。</div>
		<script>
			// 阻止 Firefox(Android) 触屏滚动，这样可以解决浏览器尺寸计算 BUG
			if(/Firefox/i.test(navigator.userAgent) && /Android/i.test(navigator.userAgent)){
				document.addEventListener('touchmove', function(event){
					if(event.touches.length >= 2){ return };
					event.preventDefault();
				}, {passive:false});
			};
		</script>
	</body>
</html>
</textarea>

<hr />
</section>



<section>
<h2>xj.viewport.set() 的参数</h2>
<p>在上面的案例中，我们都是借助 <code>meta[name="viewport"]</code> 标签上的 <code>xj-viewport</code> 这个内联属性来进行参数设置，并让插件自动执行的，但说到底自动执行也只是调用了 <code>xj.viewport.set()</code> 方法而已，例如第一个案例 <code>xj-viewport="{minWidth:512}"</code> 的写法，就相当于 <code>xj.viewport.set({minWidth:512})</code>，这方法除了上面案例中提到的参数，还有其他一些参数可供设置，下面简单的罗列一下。</p>

<textarea class="xjDemo" xjDemo="{result:false, larger:true}">
<script>
// 以下是 set() 方法可接受的参数
xj.viewport.set({
	
	minWidth : 0,				// 设置视窗的最小宽度值，默认是 0 既不设置，当设备的宽度小于该参数时将通过设置 width 和 initial-scale 将设备宽度变得符合该值
	minHeight : 0,				// 设置视窗的最小高度值，默认是 0 既不设置，当设备的高度小于该参数时将通过设置 width 和 initial-scale 将设备高度变得符合该值
	
	width : 'auto',				// 设置 width 值，默认是 'auto'，当设置为数值的时候 initial-scale 会跟着变化，设置为 'device-width' 时，initial-scale 则总 1
	height : 'auto',			// 设置 height 值，默认是 'auto'，没有任何浏览器支持视窗的 height，所以实际上插件是通过 width 属性和设备宽高比来得到目标高度
	
	maxWidth : 'none',			// 设置视窗的最大宽度值，默认是 'none' 既不设置，当宽度大于该参数，将通过设置 width & initial-scale 来将设备宽度变得符合该值
	maxHeight : 'none',			// 设置视窗的最大高度值，默认是 'none' 既不设置，当高度大于该参数，将通过设置 width & initial-scale 来将设备高度变得符合该值
	
	onlyMobile : true,			// 是否只对移动端的 meta[name="viewport"] 标签进行设置，默认是 true，为 false 则 PC 端的 meta 标签也会被设置，但视窗不会变化
	fillScreen : false,			// 同时设置了最小宽高尺寸或最大宽高尺寸，如果窗口宽高值没到达极限，是否缩放到极限，默认是 false，这一般只用于 full page 项目
	delayReset : 500,			// Android 中部分浏览器如 UC 和 IOS 中部分浏览器如 WX，旋转后立即获取尺寸会出现错误，需要延迟响应，这是延迟时间，默认 500 ms
	
	initialScale : 'auto',		// 设置 initial-scale 值，可接受 0 - 10 之间的值，默认是 'auto'，'auto' 就是让插件自动计算，这个一般不用设置，让插件计算就行
	minimumScale : 'none',		// 设置 minimum-scale 值，可接受 0 - 10 之间的值，默认是 'none'，也就是不设置，如果为 'auto'，则使用跟 initialScale 一样的值
	maximumScale : 'none',		// 设置 maximum-scale 值，可接受 0 - 10 之间的值，默认是 'none'，也就是不设置，如果为 'auto'，则使用跟 initialScale 一样的值
	userScalable : 'none',		// 设置 user-scalable 值，备选项有 'yes', 'no' 两个值，默认 'none' 既不设置，IOS10+ 会忽略该参数和上面两个控制最大最小的参数
	
	targetDensitydpi : '',		// 设置 target-densitydpi 值，默认 '' 既不设置，备选项有 high-dpi, medium-dpi, low-dpi, device-dpi，该属性实际已废弃，可忽略
	viewportFit : '',			// 设置 viewport-fit 值，默认是 '' 既不设置，备选项有 auto, cover, contain，该参数主要是针对 iPhone X 这类刘海屏幕设备的环境
	resize : true,				// 当窗口的尺寸变化或翻转时，是否要重新计算 viewport 的 content 属性，默认是 true，为 true 时注意 userScalable 参数不能为 no
	
});
</script>
</textarea>

<hr />
</section>



<section>
<h2>xj.viewport.set() 的预设</h2>
<p>上面展示了 <code>set()</code> 方法可接受的所有参数，实际上插件也提供了参数预设的方法，不过你应该用不着，因为在项目中 <code>set()</code> 方法往往调用一次就够了，所以这个参数预设的功能并没有太大意义，只是 XJ 系列的插件都有参数预设，这里也做一下而已，需要注意的是预设得在引入插件前就设置好，否则插件加载并执行时找不到预设，就会认为预设不存在，且版本号还要对得上，否则插件也不会理会的。</p>

<textarea class="xjDemo" xjDemo="{result:false, larger:true}">
<script>
// 中括号里的是版本号
if(window.xj === undefined){ xj = {} };
if(xj.viewportOption === undefined){ xj.viewportOption = {} };
xj.viewportOption['0.3.2'] = {
	// 这里可接受的内容跟 xj.viewport.set() 方法的参数值一样，
	// 所以就不再重复了，想知道这里究竟能写什么东西，看看上面 set() 方法中的对象内容就可以了。
};
</script>
</textarea>

<hr />
</section>



<section>
<h2>xj.viewport 对象</h2>
<p><code>xj.viewport</code> 对象除了上面提到的 <code>set()</code> 方法外，还有其他一些实用的属性和方法，下面罗列一下，这里较为实用的是 <code>height()</code> 方法，因为 Safari(IOS) 的 <code>window.innerHeight</code> 属性的返回值会受到窗口缩放的影响，<code>document.documentElement.clientHeight</code> 属性的返回值可能会受到地址栏的干扰，也就是说可能都不准确，但使用插件的 <code>height()</code> 方法来获取窗口高度，一般就不会出问题。</p>

<textarea class="xjDemo" xjDemo="{result:false, larger:true}">
<script>
console.log( xj.viewport.version );				// 当前插件和配置的版本号
console.log( xj.viewport.element );				// meta[name="viewport"] 标签

console.log( xj.viewport.width() ),				// 获取当前视窗的宽度，不包括地址栏和滚动部分
console.log( xj.viewport.height() ),			// 获取当前视窗的高度，不包括地址栏和滚动部分

console.log( xj.viewport.orientation() );		// 获取设备方向，landscape 或 portrait，相等返回 squared
console.log( xj.viewport.softKeyboard() );		// 判断是否有软键盘，只针对 Android，IOS 和 PC 总返回 false，因为无法得知

console.log( xj.viewport.get() );				// 获取 meta[name="viewport"] 标签的 content 属性
console.log( xj.viewport.set() );				// 设置 meta[name="viewport"] 标签的 content 属性，无返回或返回 undefined
</script>
</textarea>

<hr />
</section>



<section>
<h2>全局配置</h2>
<p>上面提到 <code>set()</code> 方法的参数预设，虽然实际上并没有太大意义，但插件还存在一个全局配置，这个你可能就会用到了，虽然配置只有两个属性：是否自动执行 <code>set()</code> 方法和 Android 上软键盘的高度判断临界值，全局配置的写法和 <code>set()</code> 方法的参数预设类似，也得在引入插件前就设置好，否则插件加载并执行时找不到全局配置，就会认为没全局配置，且版本号还要对得上，否则插件也不会理会。</p>

<textarea class="xjDemo" xjDemo="{result:false, larger:true}">
<script>
// 中括号里的是版本号
if(window.xj === undefined){ xj = {} };
if(xj.viewportConfig === undefined){ xj.viewportConfig = {} };
xj.viewportConfig['0.3.2'] = {
	
	// meta[name="viewport"] 标签上有 xj-viewport="{}" 属性时，会解析该属性并自动执行 xj.viewport.set() 方法，如果该参数为 true 则不会自动执行，默认是 false
	manual : false,
	
	// 在 Android 的浏览器中，软键盘的存在会影响到窗口尺寸，在有软键盘时不能响应视窗的重置，但实际上我们并没有任何真正靠谱的方法来检测浏览器是否弹起了软键盘
	// 只能先查看当前聚焦的节点是否为可输入元素，如果 document.activeElement 是可输入的，还要检测 screen.height - window.innherHeight 的差值，差值大于 240px
	// 才算是弹起了软键盘，240px 是赌浏览器地址栏和工具栏高度小于 240px 而小键盘高度大于 240px，在绝大多数浏览器中该判断都是成立的，但 XJ 无法保证所有浏览器
	// 都符合这个判断，如果你在开发中真的遇到了某些特殊的情况，那么可针对这个特殊情况进行浏览器的判断，并修改这个参数来进行适应，这个参数默认是 240，单位 px
	betkbd : 240,
	
};
</script>
</textarea>

<hr />
</section>



<section>
<h2>已知问题01. 在窗口高度变大时不会进行视窗尺寸重置</h2>
<p>在上面的 Demo02 中已经提过这个问题，移动端的浏览器在滚动后地址栏和工具栏可能会出现收起或展开，继而导致窗口的高度频繁发生变化，但我们并不能跟着这个变化去频繁的修改视窗属性，因为这样会引起页面抖动和视窗比例出错，插件为了解决这个问题，采用的策略是，在触发 resize 事件时，只有检测到窗口高度变小既地址栏和工具栏存在的情况，才会进行响应，而当窗口高度变大时则不理会。</p>
<p>以上这种做法，就导致了插件所设置的高度，是指地址栏和工具栏存在时的页面高度，这在真实的设备中并没有什么问题，而插件对屏幕翻转所引发的 resize 总会响应，唯一可能受到影响的就只有 Chrome 浏览器的移动模拟，当你从大屏设备转为小屏设备时，插件会出现不响应的情况，这种情况在真实环境中不大可能出现的，但有些开发者发现 Chrome 的移动模拟有时会不响应，所以这里特别解释一下。</p>
<hr />
</section>



<section>
<h2>已知问题02. Safari(IOS13-?) 横屏下最小高度的异常</h2>
<p>Safari(IOS13-) 在横屏时，就算页面的内容很少，少到并不需要滚动条，但浏览器依然会存在垂直方向的滚动条，页面在垂直方向还是能滚动，之所以会这样，是因为浏览器强行给我们的页面多加了一段高度，这高度等于地址栏的高度，这其实是浏览器 BUG，这就导致了即使我们为视窗设置了一个高度，但由于浏览器会强行给我们多加一段高度，结果最后视窗的高度就可能会比我们设置的那个高度更大。</p>
<p>阻止页面的滚动能解决问题吗？并不能，阻止滚动很容易，但在这里需要解决的问题，是让浏览器的高度正常，而不是多出来一段，但遗憾的是 XJ 并没有找到什么解决方案，值得庆幸的是这 BUG 只在横屏时才会出现，并且从 IOS14+ 开始，这个 BUG 似乎已经被修复了，截至 2022 年 9 月，<a target="_blank" href="https://developer.apple.com/support/app-store/">apple.com</a> 给出的数据是 IOS14+ 市场占比已经超过了 99%，所以这问题我们也只能无视了，毕竟也确实修不了。</p>
<hr />
</section>



<section>
<h2>已知问题03. 设备方向翻转后重设的视窗初始比例不对</h2>
<p>如果没在 <code>xj-viewport</code> 内联属性中设置 <code>resize:false</code>，也没在调用 <code>xj.viewport.set()</code> 方法时传入 <code>resize:false</code>，那么当设备发生翻转，插件就会根据翻转后的尺寸重新计算并设置视窗的宽高度了，此时视窗的比例就可能发生变化，大部分的浏览器都会帮我们把视窗比例调整为 1，此时页面既不会被放大也不会被缩小，一切都刚刚好，但有些浏览器如 Safari(IOS) 则可能会出现比例的问题。</p>
<p>问题的具体表现是，浏览器会继续保持翻转前的视窗比例，此时页面内容就可能被放大，需要用户手动操作捏合缩小比例才行，由于可能出现这种问题，所以并不推荐设置 <code>userScalable:'no'</code>，因为不允许缩放就无法手动把视窗比例调整回最合适的状态，其实从 IOS10+ 开始，IOS 也不再支持 <code>user-scalable</code> 属性了，翻转屏幕的操作比较少见，用户手动缩小一下就正常了，所以这也不算什么大问题。</p>
<hr />
</section>



<section>
<h2>项目备注</h2>
<p>01. 必须有设置 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;</code>，否则插件初始化时就有可能会出错。</p>
<p>02. 即使设置了 <code>userScalable:'no'</code>，Safari(IOS) 中页面还是能缩放，因为苹果觉得 "用户有权控制缩放"，这不是本插件的 BUG。</p>
<p>03. 有疑问或发现 BUG，可到 GitHub 提 <a target="_blank" href="https://github.com/xjZone/xj.viewport/issues">Issue</a>，如果觉得插件写得还行，在 GitHub 中为本项目点个 <a target="_blank" href="https://github.com/xjZone/xj.viewport">★Star</a> 吧，感谢啦 ಠ‿ಠ ❤。</p>
<hr />
</section>



<!-- <section><button class="xjButton xjButton-md xjButton-default xjButton-square" type="button" title="changeTheme" style="position:fixed;z-index:40;right:16px;bottom:16px;border-radius:4px;" 
onclick="$('html').toggleClass('xj-base-black')"><i class="fa fa-lightbulb"></i></button></section> -->

<script>
// 可在引入插件前，通过 xj.viewportConfig['0.3.2'] 对 set() 方法的参数进行预设，注意版本号要相同
// 可在引入插件前，通过 xj.viewportOption['0.3.2'] 对 xj.viewport 进行全局配置，注意版本号要相同
// if(window.xj === undefined){ xj = {} };

// if(xj.viewportConfig === undefined){ xj.viewportConfig = {} };
// xj.viewportConfig['0.3.2'] = {
// 	manual : true,
// 	betkbd : 248,
// };

// if(xj.viewportOption === undefined){ xj.viewportOption = {} };
// xj.viewportOption['0.3.2'] = {
//	onlyMobile : false,
//	viewportFit : 'cover',
//};
</script>

<!-- <script>document.write('<link rel="stylesheet" href="../dist/xj.viewport.css?timeStamp='+ Date.now() +'" />')</script> -->
<script>document.write('<script src="../dist/xj.viewport.js?timeStamp='+ Date.now() +'"><\/script>')</script>
<script>
$(function(){

xj.viewport.set({minWidth:400, onlyMobile:false, });
console.log(xj.viewport);

// {
// 	version : '0.3.2',		// 当前插件和配置的版本号
//	element : viewport,		// meta[name="viewport"] 标签
// 	
// 	width :ƒ(),				// 获取当前视窗的宽度，不包括地址栏和滚动部分
// 	height :ƒ(),			// 获取当前视窗的高度，不包括地址栏和滚动部分
// 	
//	orientation : ƒ(),		// 获取设备方向，landscape 或 portrait，相等返回 squared
//	softKeyboard : ƒ(),		// 判断是否有软键盘，只针对 Android，IOS 和 PC 总返回 false，因为无法得知
//	
//	get : ƒ(),				// 获取 meta[name="viewport"] 标签的 content 属性
//	set : ƒ(),				// 设置 meta[name="viewport"] 标签的 content 属性
// }

});
</script>



</body>
</html>


